Rebol [ Title: "Rebolide" File: %rebolide.r Author: "Massimiliano Vessi" Date: 2010-12-31 Version: 5.4.38 email: %maxint--tiscali--it Purpose: {A Rebol IDE for beginners that helps learning Rebol. I suggest you to put this script in a separete folder.} Library: [ level: 'intermediate platform: 'all type: [tool demo ide] domain: [all] tested-under: [view 2.7.7.3.1 Windows Linux ] support: %maxint--tiscali--it license: 'gpl see-also: none ] ] ;notify "I'm adding new buttons every day. So I promise to tidying up the buttons when I'll finish." ;thanks to Graham, Nick Antonaccio, Semseddin Moldibi, Zoltan Eros, R. v.d.Zee yv1: to-block { label "Words" return label "Blocks" return label "Functions" return label "Objects"} ; function to find object, function, etc. in your source findall: func [ a_findall /local temp temp2 ] [ temp: copy [] temp: copy to-block a_findall variabili: copy [] funzioni: copy [] blocchi: copy [] oggetti: copy [] foreach item temp [ tipo: false if ((type? item) = set-word!) [ if ( temp/2 = 'func ) [ append funzioni item tipo: true ] if ( temp/2 = 'make ) [ append oggetti item tipo: true] if ( (type? temp/2 ) = block! ) [ append blocchi item tipo: true] if tipo = false [ append variabili item ] ] temp: next temp ] sort funzioni sort oggetti sort blocchi sort variabili return (reduce [ "functions" funzioni "objects" oggetti "blocks" blocchi "words" variabili]) ] ;Return the usage of every command utilizzo: func [ "Prints information about words and values." 'word [any-type!] /local value args item type-name refmode types attrs rtype temp4 ][ temp4: copy [] if all [word? :word not value? :word] [word: mold :word] if any [string? :word all [word? :word datatype? get :word]] [ types: dump-obj/match system/words :word sort types if not empty? types [ return reform ["Found these words:" newline types] exit ] return reform ["No information on" word "(word has no value)"] exit ] type-name: func [value] [ value: mold type? :value clear back tail value join either find "aeiou" first value ["an "] ["a "] value ] if not any [word? :word path? :word] [ return reform [mold :word "is" type-name :word] exit ] value: either path? :word [first reduce reduce [word]] [get :word] if not any-function? :value [ append temp4 [uppercase mold word "is" type-name :value "of value: "] append temp4 either object? value [print "" dump-obj value] [mold :value] return reform temp4 exit ] args: third :value append temp4 "USAGE: " if not op? :value [append temp4 (append uppercase mold word " ")] while [not tail? args] [ item: first args if :item = /local [break] if any [all [any-word? :item not set-word? :item] refinement? :item] [ append temp4 (append mold :item " ") if op? :value [append temp4 (append uppercase mold word " " value: none)] ] args: next args ] return reform temp4 ] ;functio to insert text in the source area inni: func [testo2 /local temp3] [ set-text/caret a testo2 temp3: parse testo2 none temp3: to-word first temp3 temp3: utilizzo :temp3 uso/text: to-string temp3 show uso ] filep: none ;file path and name ;save as file function saveas: func [] [ filen: request-value "File name?" filed: to-file request-dir filep: to-file rejoin [ filed filen] salva ] ;save file function salva: func [] [ if filep = none [ saveas ] write filep a/text set-text testo reform ["Saved as " filep ] ] ;to launch soirce or examples lancia: func [ temp /local corpo ] [ corpo: copy temp insert corpo "Rebol [] " write %temp.r corpo launch (clean-path %temp.r) ;clean-path is necessary on Linux ] ;check Rebgui existance and version if not (exists? %rebgui.r) [ Alert "Rebgui not found, I'll try to download it" temp: request-download http://www.dobeash.com/RebGUI/rebgui.r temp: decompress skip temp 8 write %rebgui.r temp ] if (exists? %rebgui.r ) [ temp: load/header %rebgui.r if (temp/1/version <> 117 ) [ alert "Watch out, your RebGUI version is different from 117; this script could not work properly!"] ] ;block with al converion functions allconverions: [to-binary to-bitset to-block to-char to-closure to-datatype to-date to-decimal to-email to-error t
